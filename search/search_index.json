{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#virtual-laser-scanning-of-dynamic-scenes-vls-4d","title":"Virtual Laser Scanning of Dynamic Scenes (VLS-4D)","text":"<p>Author: Hannah Weiser  Contributors: Bernhard H\u00f6fle  Year: 2025</p> <p>This webpage provides an overview of the VLS-4D framework using a variety of examples from the field of vegetation monitoring, simulated with the Heidelberg LiDAR Operations Simulator HELIOS++.</p> <p>VLS-4D refers to VLS of dynamic scenes. This means that instead of loading a static 3D scene and virtually scanning it in a single epoch, as done by the majority of recent studies, we work with a dynamic scene.</p> <p>This opens up a range of application in the field of remote sensing of the environment.</p> <p> </p> <p>This dynamic scene can be represented as (a) a sequence of static 3D scenes (e.g., 3D meshes), or by (b) a single 3D scene that changes during the simulation.</p> <p>In the case of a sequence of static 3D scenes, each scene represents a different point in time. We can scan the different versions of the scene in multiple surveys to create multi-temporal laser scanning point clouds or point cloud time series. Or the static versions represent the dynamics of a scene within a single survey, which is divided into several snapshots, e.g., the individual scans in a multi-station TLS campaign. </p> <p>In the case of a single animated 3D scene, the scene moves or deforms during the simulation, i.e., within a single epoch. In HELIOS++, object movements in the form of rigid motions (e.g., translation, rotation) are supported and can be defined via the scene XML syntax. </p> <p>These mechanisms lead to three concept of VLS-4D: The concept of static representations, the concept of many static sapshots, and the concept of animation within the simulation.</p> <p> </p> <p>In three notebooks, we will give illustrate each concept with relevant application examples from vegetation monitoring. We provide all necessary code to reproduce the results. This way, you can learn how to use the VLS-4D framework for your own research.</p> <p>Use the following links to directly access the notebooks:</p> <ol> <li>Static Representations</li> <li>Many Static Snapshots</li> <li>Animation within the Simulation</li> </ol> <p>Funding:</p> <p></p> DFG (Deutsche Forschungsgemeinschaft, German Research Foundation) Project Project number VirtuaLearn3D 496418931 Fostering a community-driven and sustainable HELIOS++ scientific software 528521476 <p></p> <p></p> BMBF (Bundesministerium f\u00fcr Bildung und Forschung, Federal Ministry of Education and Research) Project Funding code AIMON5.0 02WDG1696 <p></p> <p>Contact</p>"},{"location":"01_static_snapshot_per_epoch.html","title":"1 Concept of a static snapshot per epoch","text":"In\u00a0[1]: Copied! <pre>import os\nos.chdir('../demo')\n</pre> import os os.chdir('../demo') In\u00a0[2]: Copied! <pre>from pathlib import Path\nfrom IPython.display import Code\nfrom scripts.nb_utils import read_pc, read_from_output_folder, display_xml\nimport pyhelios\nfrom pyhelios.util.xmldisplayer import find_playback_dir\nimport numpy as np\nimport pyvista as pv\npv.set_jupyter_backend('trame')\n</pre> from pathlib import Path from IPython.display import Code from scripts.nb_utils import read_pc, read_from_output_folder, display_xml import pyhelios from pyhelios.util.xmldisplayer import find_playback_dir import numpy as np import pyvista as pv pv.set_jupyter_backend('trame') In\u00a0[3]: Copied! <pre>Code(display_xml('data/scenes/forest_t1.xml', line_limit=31), language='XML')\n</pre> Code(display_xml('data/scenes/forest_t1.xml', line_limit=31), language='XML') Out[3]: <pre>&lt;document&gt;\n    &lt;scene id=\"forest_scene\" name=\"Forest scene\"&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/forest_t1/Circle.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/forest_t1/tree1.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/forest_t1/tree2.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/forest_t1/tree3.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n</pre> <p>We can display the scene with pyvista and create a nice gif:</p> In\u00a0[5]: Copied! <pre>filenames1 = Path('data/sceneparts/forest_t1').glob('*.obj')\nfilenames2 = Path('data/sceneparts/forest_t2').glob('*.obj')\n\np = pv.Plotter(notebook=True, shape=(1, 2), window_size=(1000, 500), off_screen=True)\nfor filename in filenames1:\n    mesh = pv.read(str(filename))\n    p.add_mesh(mesh)\np.add_text('Forest mesh at t=1', color='k')\np.subplot(0, 1)\nfor filename in filenames2:\n    mesh = pv.read(str(filename))\n    p.add_mesh(mesh)\np.add_text('Forest mesh at t=2', color='k')\np.link_views()\np.camera_position = 'xz'\np.camera.zoom(1.8)\npath = p.generate_orbital_path(n_points=50, shift=mesh.length)\np.open_gif('../docs/img/forest_orbit.gif')\np.orbit_on_path(path, write_frames=True)\np.close()\n</pre> filenames1 = Path('data/sceneparts/forest_t1').glob('*.obj') filenames2 = Path('data/sceneparts/forest_t2').glob('*.obj')  p = pv.Plotter(notebook=True, shape=(1, 2), window_size=(1000, 500), off_screen=True) for filename in filenames1:     mesh = pv.read(str(filename))     p.add_mesh(mesh) p.add_text('Forest mesh at t=1', color='k') p.subplot(0, 1) for filename in filenames2:     mesh = pv.read(str(filename))     p.add_mesh(mesh) p.add_text('Forest mesh at t=2', color='k') p.link_views() p.camera_position = 'xz' p.camera.zoom(1.8) path = p.generate_orbital_path(n_points=50, shift=mesh.length) p.open_gif('../docs/img/forest_orbit.gif') p.orbit_on_path(path, write_frames=True) p.close() <p></p> In\u00a0[5]: Copied! <pre>Code(display_xml('data/surveys/uls_forest_t1.xml'), language='XML')\n</pre> Code(display_xml('data/surveys/uls_forest_t1.xml'), language='XML') Out[5]: <pre>&lt;document&gt;\n\t&lt;scannerSettings id=\"uls_templ\" active=\"true\" pulseFreq_hz=\"100000\" scanAngle_deg=\"90\" scanFreq_hz=\"75\" headRotatePerSec_deg=\"0.00\" trajectoryTimeInterval_s=\"0.01\" /&gt;\n    &lt;survey name=\"forest_t1\" seed=\"42\" scene=\"data/scenes/forest_t1.xml#forest_scene\" platform=\"data/platforms.xml#copter_linearpath\" scanner=\"data/scanners_als.xml#riegl_vux-1uav\"&gt;\n\t&lt;FWFSettings beamSampleQuality=\"3\" binSize_ns=\"0.25\" maxFullwaveRange_ns=\"100\" winSize_ns=\"1.5\" /&gt;\n\t\t&lt;!-- platform: copter_linearpath, deflector: rotating --&gt;\n\t\t\n\t\t&lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"-32\" y=\"-20\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" /&gt;\n\t\t&lt;/leg&gt;\n\t\t\n\t\t&lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"24\" y=\"-20\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" active=\"false\" /&gt;\n\t\t&lt;/leg&gt;\n        \n        &lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"24\" y=\"-6\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" /&gt;\n\t\t&lt;/leg&gt;\n\t\t\n\t\t&lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"-32\" y=\"-6\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" active=\"false\" /&gt;\n\t\t&lt;/leg&gt;\n        \n        \t\t&lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"-32\" y=\"8\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" /&gt;\n\t\t&lt;/leg&gt;\n\t\t\n\t\t&lt;leg&gt;\n\t\t\t&lt;platformSettings x=\"24\" y=\"8\" z=\"75\" onGround=\"false\" movePerSec_m=\"5\" /&gt;\n\t\t\t&lt;scannerSettings template=\"uls_templ\" active=\"false\" /&gt;\n\t\t&lt;/leg&gt;\n\n    &lt;/survey&gt;\n&lt;/document&gt;\n</pre> In\u00a0[7]: Copied! <pre>!helios data/surveys/uls_forest_t1.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/uls_forest_t1.xml -q --lasOutput --zipOutput --rebuildScene <p>The following code loads the points from the output folder and merges the flight lines.</p> In\u00a0[6]: Copied! <pre>survey_file = 'data/surveys/uls_forest_t1.xml'\noutput_path = find_playback_dir(survey_file)\n\nprint(\"Loading points from\", Path(output_path))\npc_t1, object_id_t1, _, _, _, _ = read_from_output_folder(output_path)\n</pre> survey_file = 'data/surveys/uls_forest_t1.xml' output_path = find_playback_dir(survey_file)  print(\"Loading points from\", Path(output_path)) pc_t1, object_id_t1, _, _, _, _ = read_from_output_folder(output_path) <pre>Loading points from D:\\Software\\vls-4d\\demo\\output\\forest_t1\\2025-03-08_21-07-05\n</pre> In\u00a0[9]: Copied! <pre>!helios data/surveys/uls_forest_t2.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/uls_forest_t2.xml -q --lasOutput --zipOutput --rebuildScene In\u00a0[7]: Copied! <pre>survey_file = 'data/surveys/uls_forest_t2.xml'\noutput_path = find_playback_dir(survey_file)\n\nprint(\"Loading points from\", Path(output_path))\npc_t2, object_id_t2, _, _, _, _ = read_from_output_folder(output_path)\n</pre> survey_file = 'data/surveys/uls_forest_t2.xml' output_path = find_playback_dir(survey_file)  print(\"Loading points from\", Path(output_path)) pc_t2, object_id_t2, _, _, _, _ = read_from_output_folder(output_path) <pre>Loading points from D:\\Software\\vls-4d\\demo\\output\\forest_t2\\2025-03-08_21-16-56\n</pre> In\u00a0[8]: Copied! <pre>pl = pv.Plotter(shape=(1, 2))\n# t1\nactor = pl.add_points(pc_t1, scalars=object_id_t1, style='points', render_points_as_spheres=True, point_size=5)\npl.remove_scalar_bar()\npl.add_text('Forest at t=1', color='k')\n\n# t2\npl.subplot(0, 1)\nactor = pl.add_points(pc_t2, scalars=object_id_t2, style='points', render_points_as_spheres=True, point_size=5)\npl.remove_scalar_bar()\npl.add_text('Forest at t=2', color='k')\n\npl.link_views()\npl.camera_position = 'xz'\npl.camera.zoom(1.8)\npl.show()\n</pre> pl = pv.Plotter(shape=(1, 2)) # t1 actor = pl.add_points(pc_t1, scalars=object_id_t1, style='points', render_points_as_spheres=True, point_size=5) pl.remove_scalar_bar() pl.add_text('Forest at t=1', color='k')  # t2 pl.subplot(0, 1) actor = pl.add_points(pc_t2, scalars=object_id_t2, style='points', render_points_as_spheres=True, point_size=5) pl.remove_scalar_bar() pl.add_text('Forest at t=2', color='k')  pl.link_views() pl.camera_position = 'xz' pl.camera.zoom(1.8) pl.show() In\u00a0[9]: Copied! <pre>Code(display_xml('data/scenes/tree_defoliation.xml'), language='XML')\n</pre> Code(display_xml('data/scenes/tree_defoliation.xml'), language='XML') Out[9]: <pre>&lt;document&gt;\n    &lt;scene id=\"swap_scene\" name=\"Dynamic scene\"&gt;\n        \n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/tree_defoliation/wood.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;!-- two more steps with the same wood\" --&gt; \n            &lt;swap swapStep=\"2\"&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/tree_defoliation/wood.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;/swap&gt;\n            &lt;!-- swap fine wood structure by just the main banches (-&gt; branch dieback) for the last step --&gt;\n            &lt;swap swapStep=\"1\"&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/tree_defoliation/wood_reduced.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;/swap&gt;\n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/tree_defoliation/leaves_green.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;!-- swap green leaves for yellow leaves --&gt;\n            &lt;swap swapStep=\"1\"&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/tree_defoliation/leaves_yellow.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;/swap&gt;\n            &lt;!-- no leaves at all for two steps --&gt;\n            &lt;swap swapStep=\"2\" force_null=\"true\"&gt;\n            &lt;/swap&gt;\n        &lt;/part&gt;\n    &lt;/scene&gt;\n&lt;/document&gt;\n</pre> <p>The tree has been reconstructed from a real point cloud using TreeQSM and the leaves have been added using QSM-FanNNI. Let's have a quick look at the scene parts in 3D.</p> In\u00a0[10]: Copied! <pre>p = pv.Plotter(notebook=True, shape=(2, 2), window_size=(600, 600))\nmesh = pv.read('data/sceneparts/tree_defoliation/wood.obj')\np.add_mesh(mesh, color=\"saddlebrown\")\np.add_text('Wood', color='k', font_size=12)\np.subplot(0, 1)\nmesh = pv.read('data/sceneparts/tree_defoliation/leaves_green.obj')\np.add_mesh(mesh, color=\"forestgreen\")\np.add_text('Leaves green', color='k', font_size=12)\np.subplot(1, 0)\nmesh = pv.read('data/sceneparts/tree_defoliation/wood_reduced.obj')\np.add_mesh(mesh, color=\"saddlebrown\")\np.add_text('Wood reduced', color='k', font_size=12)\np.subplot(1, 1)\nmesh = pv.read('data/sceneparts/tree_defoliation/leaves_yellow.obj')\np.add_mesh(mesh, color=\"yellow\")\np.add_text('Leaves yellow and smaller', color='k', font_size=12)\np.link_views()\np.camera_position = 'xz'\np.camera.zoom(1)\np.show()\n</pre> p = pv.Plotter(notebook=True, shape=(2, 2), window_size=(600, 600)) mesh = pv.read('data/sceneparts/tree_defoliation/wood.obj') p.add_mesh(mesh, color=\"saddlebrown\") p.add_text('Wood', color='k', font_size=12) p.subplot(0, 1) mesh = pv.read('data/sceneparts/tree_defoliation/leaves_green.obj') p.add_mesh(mesh, color=\"forestgreen\") p.add_text('Leaves green', color='k', font_size=12) p.subplot(1, 0) mesh = pv.read('data/sceneparts/tree_defoliation/wood_reduced.obj') p.add_mesh(mesh, color=\"saddlebrown\") p.add_text('Wood reduced', color='k', font_size=12) p.subplot(1, 1) mesh = pv.read('data/sceneparts/tree_defoliation/leaves_yellow.obj') p.add_mesh(mesh, color=\"yellow\") p.add_text('Leaves yellow and smaller', color='k', font_size=12) p.link_views() p.camera_position = 'xz' p.camera.zoom(1) p.show() In\u00a0[11]: Copied! <pre>Code(display_xml('data/surveys/defoliation_time_series.xml'), language='XML')\n</pre> Code(display_xml('data/surveys/defoliation_time_series.xml'), language='XML') Out[11]: <pre>&lt;document&gt;\n        &lt;scannerSettings id=\"tls\" active=\"true\" pulseFreq_hz=\"300000\" verticalResolution_deg=\"0.034\" horizontalResolution_deg=\"0.034\" /&gt;\n        &lt;survey name=\"tree_defoliation\" platform=\"data/platforms.xml#tripod\" scanner=\"data/scanners_tls.xml#riegl_vz400\" scene=\"data/scenes/tree_defoliation.xml#swap_scene\"&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"-15\" y=\"0\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"240\" headRotateStop_deg=\"300\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"-4.4\" y=\"11.7\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"195\" headRotateStop_deg=\"255\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"14.3\" y=\"6\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"105\" headRotateStop_deg=\"165\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"12.3\" y=\"-11.8\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"15\" headRotateStop_deg=\"75\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"-9.4\" y=\"-12.6\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"285\" headRotateStop_deg=\"345\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        \n        &lt;/survey&gt;\n    &lt;/document&gt;\n</pre> In\u00a0[15]: Copied! <pre>!helios data/surveys/defoliation_time_series.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/defoliation_time_series.xml -q --lasOutput --zipOutput --rebuildScene In\u00a0[12]: Copied! <pre>output_path = Path(find_playback_dir('data/surveys/defoliation_time_series.xml')).parent\noutfolders = list(Path(output_path).glob('2025*'))[-4:]\n\npc_t1, _, classification_t1, amplitude_t1, _, _ = read_from_output_folder(outfolders[0])\npc_t2, _, classification_t2, amplitude_t2, _, _ = read_from_output_folder(outfolders[1])\npc_t3, _, classification_t3, amplitude_t3, _, _ = read_from_output_folder(outfolders[2])\npc_t4, _, classification_t4, amplitude_t4, _, _ = read_from_output_folder(outfolders[3])\n</pre> output_path = Path(find_playback_dir('data/surveys/defoliation_time_series.xml')).parent outfolders = list(Path(output_path).glob('2025*'))[-4:]  pc_t1, _, classification_t1, amplitude_t1, _, _ = read_from_output_folder(outfolders[0]) pc_t2, _, classification_t2, amplitude_t2, _, _ = read_from_output_folder(outfolders[1]) pc_t3, _, classification_t3, amplitude_t3, _, _ = read_from_output_folder(outfolders[2]) pc_t4, _, classification_t4, amplitude_t4, _, _ = read_from_output_folder(outfolders[3]) In\u00a0[13]: Copied! <pre>p = pv.Plotter(notebook=True, shape=(1, 4), window_size=(1200, 400))\np.add_points(pc_t1[::2], scalars=amplitude_t1[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 1'}, show_scalar_bar=False)\np.add_text('t=1', color='k')\np.subplot(0, 1)\np.add_points(pc_t2[::2], scalars=amplitude_t2[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 2'}, show_scalar_bar=False)\np.add_text('t=2', color='k')\np.subplot(0, 2)\np.add_points(pc_t3[::2], scalars=amplitude_t3[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 3'}, show_scalar_bar=False)\np.add_text('t=3', color='k')\np.subplot(0, 3)\np.add_points(pc_t4[::2], scalars=amplitude_t4[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 4'}, show_scalar_bar=False)\np.add_text('t=4', color='k')\n#p.add_scalar_bar(\n#    'helios amplitude',\n#    vertical=False,\n#    title_font_size=20,\n#    label_font_size=16,\n#    outline=False,\n#    fmt='%10.1f',\n#    n_labels=0\n#)\np.link_views()\np.camera_position = 'xz'\np.camera.zoom(1)\np.show()\n</pre> p = pv.Plotter(notebook=True, shape=(1, 4), window_size=(1200, 400)) p.add_points(pc_t1[::2], scalars=amplitude_t1[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 1'}, show_scalar_bar=False) p.add_text('t=1', color='k') p.subplot(0, 1) p.add_points(pc_t2[::2], scalars=amplitude_t2[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 2'}, show_scalar_bar=False) p.add_text('t=2', color='k') p.subplot(0, 2) p.add_points(pc_t3[::2], scalars=amplitude_t3[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 3'}, show_scalar_bar=False) p.add_text('t=3', color='k') p.subplot(0, 3) p.add_points(pc_t4[::2], scalars=amplitude_t4[::2], style='points', cmap='gwv', point_size=1, scalar_bar_args={'title': 'amplitude | 4'}, show_scalar_bar=False) p.add_text('t=4', color='k') #p.add_scalar_bar( #    'helios amplitude', #    vertical=False, #    title_font_size=20, #    label_font_size=16, #    outline=False, #    fmt='%10.1f', #    n_labels=0 #) p.link_views() p.camera_position = 'xz' p.camera.zoom(1) p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"01_static_snapshot_per_epoch.html#1-concept-of-one-static-snapshot-per-epoch","title":"1 Concept of one static snapshot per epoch\u00b6","text":""},{"location":"01_static_snapshot_per_epoch.html#imports","title":"Imports\u00b6","text":""},{"location":"01_static_snapshot_per_epoch.html#example-11-bi-temporal-uav-borne-laser-scanning-of-a-growing-forest","title":"Example 1.1: Bi-temporal UAV-borne laser scanning of a growing forest\u00b6","text":"<p>We start with a small homogeneous plot of trees that have been created with the Sapling Tree Gen add-on in Blender, which is based on the algorithm by Weber &amp; Penn (1995). To generate the second time step, the trees are scaled in place in Blender.</p>"},{"location":"01_static_snapshot_per_epoch.html#the-scene","title":"The scene\u00b6","text":"<p>This is how the XML scene file looks like:</p>"},{"location":"01_static_snapshot_per_epoch.html#the-survey","title":"The survey\u00b6","text":"<p>The survey is a simple UAV-borne laser scanning (ULS) survey with three flight lines at an altitude of 75 m above ground level.</p>"},{"location":"01_static_snapshot_per_epoch.html#executing-the-simulations","title":"Executing the simulations\u00b6","text":"<p>In JupyterLab, we can run external commands with the !command syntax. We will use this to run the simulations for time steps 1 and 2, which are exactly the same except for the different scene.</p>"},{"location":"01_static_snapshot_per_epoch.html#visualizing-the-output","title":"Visualizing the output\u00b6","text":""},{"location":"01_static_snapshot_per_epoch.html#example-12-terrestrial-laser-scanning-tls-time-series-of-tree-defoliation-swap-on-repeat","title":"Example 1.2: Terrestrial laser scanning (TLS) time series of tree defoliation (swap-on-repeat)\u00b6","text":"<p>The concept of static representations can also be implemented in an easier way using swap-on-repeat. This HELIOS++ feature allows to define a dynamic scene of several snapshots in a single scene XML. In this XML, a scene part can have several \"swaps\" for a defined number of epochs, where the scene part geometry can be exchanged, or transformation filters can be applied. We will use this to create a small time series of a tree which undergoes defoliation.</p>"},{"location":"01_static_snapshot_per_epoch.html#the-scene","title":"The scene\u00b6","text":"<p>This is what the scene looks like:</p>"},{"location":"01_static_snapshot_per_epoch.html#the-survey","title":"The survey\u00b6","text":"<p>The survey is a simple multi-station terrestrial laser scanning (TLS) setup with five scan positions:</p>"},{"location":"01_static_snapshot_per_epoch.html#executing-the-simulations","title":"Executing the simulations\u00b6","text":"<p>This time, we only have to execute the survey once, and it will automatically be repeated for as many swaps as have been detected in the scene XML file (in this case: 4).</p>"},{"location":"01_static_snapshot_per_epoch.html#visualizing-the-output","title":"Visualizing the Output\u00b6","text":"<p>Let's have a look at the four output point clouds that we have simulated:</p>"},{"location":"02_static_snapshots_within_epoch.html","title":"2 Concept of several static snapshots within an epoch","text":"In\u00a0[1]: Copied! <pre>import os\nos.chdir('../demo')\n</pre> import os os.chdir('../demo') In\u00a0[2]: Copied! <pre>from pathlib import Path\nfrom IPython.display import Code\nfrom scripts.nb_utils import read_pc, read_from_output_folder, display_xml\nimport pyhelios\nfrom pyhelios.util.xmldisplayer import find_playback_dir\nimport numpy as np\nimport pyvista as pv\npv.set_jupyter_backend('trame')\n</pre> from pathlib import Path from IPython.display import Code from scripts.nb_utils import read_pc, read_from_output_folder, display_xml import pyhelios from pyhelios.util.xmldisplayer import find_playback_dir import numpy as np import pyvista as pv pv.set_jupyter_backend('trame') In\u00a0[3]: Copied! <pre>Code(display_xml('data/scenes/white_birch_005.xml'), language='XML')\n</pre> Code(display_xml('data/scenes/white_birch_005.xml'), language='XML') Out[3]: <pre>&lt;document&gt;\n    &lt;scene id=\"scene\" name=\"Scene\"&gt;\n        \n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data\\sceneparts\\white_birch\\leaves_005.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n        &lt;/part&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data\\sceneparts\\white_birch\\tree_005.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n        &lt;/part&gt;\n    &lt;/scene&gt;\n&lt;/document&gt;\n</pre> <p>If we plot all the scene parts we exported, we can clearly see that the tree moved. This is what is looks like:</p> In\u00a0[4]: Copied! <pre>filenames_wood = list(Path('data/sceneparts/white_birch').glob('tree*.obj'))\nfilenames_leaves = list(Path('data/sceneparts/white_birch').glob('leaves*.obj'))\n\np = pv.Plotter(notebook=True, off_screen=True)\nmesh_wood = pv.read(str(filenames_wood[0]))\na1 = p.add_mesh(mesh_wood, color=\"saddlebrown\")\nmesh_leaves = pv.read(str(filenames_leaves[0]))\na2 = p.add_mesh(mesh_leaves, color=\"forestgreen\")\np.camera_position = 'xz'\np.camera.zoom(1.5)\nframe = filenames_wood[0].stem[-3:]\nt = p.add_text(f\"Frame {frame}\", color=\"k\")\n\n# Open a gif\np.open_gif(\"../docs/img/tree_sway.gif\")\nfor _ in range(5):  # to make the gif slower\n    p.write_frame()\n    \n# Update mesh and write a frame for each update\nfor m_wood, m_leaves in zip(filenames_wood[1:], filenames_leaves[1:]):\n    p.remove_actor(a1)\n    p.remove_actor(a2)\n    p.remove_actor(t)\n    mesh_wood = pv.read(str(m_wood))\n    mesh_leaves = pv.read(str(m_leaves))\n    a1 = p.add_mesh(mesh_wood, color=\"saddlebrown\")\n    a2 = p.add_mesh(mesh_leaves, color=\"forestgreen\")\n    frame = m_wood.stem[-3:]\n    t = p.add_text(f\"Frame {frame}\", color=\"k\")\n    for _ in range(5):  # to make the gif slower\n        p.write_frame()\n\n# Closes and finalizes movie\np.close()\n</pre> filenames_wood = list(Path('data/sceneparts/white_birch').glob('tree*.obj')) filenames_leaves = list(Path('data/sceneparts/white_birch').glob('leaves*.obj'))  p = pv.Plotter(notebook=True, off_screen=True) mesh_wood = pv.read(str(filenames_wood[0])) a1 = p.add_mesh(mesh_wood, color=\"saddlebrown\") mesh_leaves = pv.read(str(filenames_leaves[0])) a2 = p.add_mesh(mesh_leaves, color=\"forestgreen\") p.camera_position = 'xz' p.camera.zoom(1.5) frame = filenames_wood[0].stem[-3:] t = p.add_text(f\"Frame {frame}\", color=\"k\")  # Open a gif p.open_gif(\"../docs/img/tree_sway.gif\") for _ in range(5):  # to make the gif slower     p.write_frame()      # Update mesh and write a frame for each update for m_wood, m_leaves in zip(filenames_wood[1:], filenames_leaves[1:]):     p.remove_actor(a1)     p.remove_actor(a2)     p.remove_actor(t)     mesh_wood = pv.read(str(m_wood))     mesh_leaves = pv.read(str(m_leaves))     a1 = p.add_mesh(mesh_wood, color=\"saddlebrown\")     a2 = p.add_mesh(mesh_leaves, color=\"forestgreen\")     frame = m_wood.stem[-3:]     t = p.add_text(f\"Frame {frame}\", color=\"k\")     for _ in range(5):  # to make the gif slower         p.write_frame()  # Closes and finalizes movie p.close() <p></p> In\u00a0[5]: Copied! <pre>Code(display_xml('data/surveys/white_birch_0.xml'), language='XML')\n</pre> Code(display_xml('data/surveys/white_birch_0.xml'), language='XML') Out[5]: <pre>&lt;document&gt;\n        &lt;scannerSettings id=\"tls\" active=\"true\" pulseFreq_hz=\"600000\" verticalResolution_deg=\"0.04\" horizontalResolution_deg=\"0.04\" /&gt;\n        &lt;survey name=\"white_birch_0\" platform=\"data/platforms_custom.xml#tripod_tilt_1_of_6\" scanner=\"data/scanners_tls.xml#riegl_vz400\" scene=\"data/scenes/white_birch_029.xml#scene\"&gt;\n            &lt;leg&gt;\n            &lt;platformSettings x=\"16.0000\" y=\"0.0000\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"0.0000\" headRotateStop_deg=\"120.0000\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        \n        &lt;/survey&gt;\n    &lt;/document&gt;\n</pre> In\u00a0[7]: Copied! <pre>!helios data/surveys/white_birch_0.xml -q --lasOutput --zipOutput --rebuildScene\n!helios data/surveys/white_birch_1.xml -q --lasOutput --zipOutput --rebuildScene\n!helios data/surveys/white_birch_2.xml -q --lasOutput --zipOutput --rebuildScene\n!helios data/surveys/white_birch_3.xml -q --lasOutput --zipOutput --rebuildScene\n!helios data/surveys/white_birch_4.xml -q --lasOutput --zipOutput --rebuildScene\n!helios data/surveys/white_birch_5.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/white_birch_0.xml -q --lasOutput --zipOutput --rebuildScene !helios data/surveys/white_birch_1.xml -q --lasOutput --zipOutput --rebuildScene !helios data/surveys/white_birch_2.xml -q --lasOutput --zipOutput --rebuildScene !helios data/surveys/white_birch_3.xml -q --lasOutput --zipOutput --rebuildScene !helios data/surveys/white_birch_4.xml -q --lasOutput --zipOutput --rebuildScene !helios data/surveys/white_birch_5.xml -q --lasOutput --zipOutput --rebuildScene In\u00a0[6]: Copied! <pre># reading and merging\noutput_path = Path(find_playback_dir('data/surveys/white_birch_0.xml'))\npc_t1, _, classification_t1, helios_amplitude_t1, _, pt_src_id_t1 = read_pc(output_path / 'leg000_points.laz', 0)\noutput_path = Path(find_playback_dir('data/surveys/white_birch_1.xml'))\npc_t2, _, classification_t2, helios_amplitude_t2, _, pt_src_id_t2 = read_pc(output_path / 'leg000_points.laz', 1)\noutput_path = Path(find_playback_dir('data/surveys/white_birch_2.xml'))\npc_t3, _, classification_t3, helios_amplitude_t3, _, pt_src_id_t3 = read_pc(output_path / 'leg000_points.laz', 2)\noutput_path = Path(find_playback_dir('data/surveys/white_birch_3.xml'))\npc_t4, _, classification_t4, helios_amplitude_t4, _, pt_src_id_t4 = read_pc(output_path / 'leg000_points.laz', 3)\noutput_path = Path(find_playback_dir('data/surveys/white_birch_4.xml'))\npc_t5, _, classification_t5, helios_amplitude_t5, _, pt_src_id_t5 = read_pc(output_path / 'leg000_points.laz', 4)\noutput_path = Path(find_playback_dir('data/surveys/white_birch_5.xml'))\npc_t6, _, classification_t6, helios_amplitude_t6, _, pt_src_id_t6 = read_pc(output_path / 'leg000_points.laz', 5)\n\npc = pc = np.vstack([pc_t1, pc_t2, pc_t3, pc_t4, pc_t5, pc_t6])\nclassification = np.hstack([classification_t1, classification_t2, classification_t3, classification_t4, classification_t5, classification_t6])\nhelios_amplitude = np.hstack([helios_amplitude_t1, helios_amplitude_t2, helios_amplitude_t3, helios_amplitude_t4, helios_amplitude_t5, helios_amplitude_t6])\npt_src_id = np.hstack([pt_src_id_t1, pt_src_id_t2, pt_src_id_t3, pt_src_id_t4, pt_src_id_t5, pt_src_id_t6 ])\n</pre> # reading and merging output_path = Path(find_playback_dir('data/surveys/white_birch_0.xml')) pc_t1, _, classification_t1, helios_amplitude_t1, _, pt_src_id_t1 = read_pc(output_path / 'leg000_points.laz', 0) output_path = Path(find_playback_dir('data/surveys/white_birch_1.xml')) pc_t2, _, classification_t2, helios_amplitude_t2, _, pt_src_id_t2 = read_pc(output_path / 'leg000_points.laz', 1) output_path = Path(find_playback_dir('data/surveys/white_birch_2.xml')) pc_t3, _, classification_t3, helios_amplitude_t3, _, pt_src_id_t3 = read_pc(output_path / 'leg000_points.laz', 2) output_path = Path(find_playback_dir('data/surveys/white_birch_3.xml')) pc_t4, _, classification_t4, helios_amplitude_t4, _, pt_src_id_t4 = read_pc(output_path / 'leg000_points.laz', 3) output_path = Path(find_playback_dir('data/surveys/white_birch_4.xml')) pc_t5, _, classification_t5, helios_amplitude_t5, _, pt_src_id_t5 = read_pc(output_path / 'leg000_points.laz', 4) output_path = Path(find_playback_dir('data/surveys/white_birch_5.xml')) pc_t6, _, classification_t6, helios_amplitude_t6, _, pt_src_id_t6 = read_pc(output_path / 'leg000_points.laz', 5)  pc = pc = np.vstack([pc_t1, pc_t2, pc_t3, pc_t4, pc_t5, pc_t6]) classification = np.hstack([classification_t1, classification_t2, classification_t3, classification_t4, classification_t5, classification_t6]) helios_amplitude = np.hstack([helios_amplitude_t1, helios_amplitude_t2, helios_amplitude_t3, helios_amplitude_t4, helios_amplitude_t5, helios_amplitude_t6]) pt_src_id = np.hstack([pt_src_id_t1, pt_src_id_t2, pt_src_id_t3, pt_src_id_t4, pt_src_id_t5, pt_src_id_t6 ]) In\u00a0[7]: Copied! <pre>p = pv.Plotter(notebook=True, shape=(1, 2)) \np.add_points(pc[::3], \n             scalars=pt_src_id[::3].astype('int32'),\n             style='points',\n             #cmap='gwv',\n             point_size=2,\n             scalar_bar_args={'title': 'Point Source ID',\n                              'n_labels': 6,\n                              'position_x': 0.3})\np.subplot(0, 1)\np.add_points(pc[::3],\n             scalars=classification[::3],\n             style='points',\n             cmap=['saddlebrown', 'forestgreen'],\n             render_points_as_spheres=True,\n             point_size=2,\n             scalar_bar_args={'title': 'Classification',\n                              'n_labels': 2,\n                              'position_x': 0.3})\np.link_views()\np.camera_position = 'xz'\np.camera.zoom(3)\np.show_axes()\np.show()\n</pre> p = pv.Plotter(notebook=True, shape=(1, 2))  p.add_points(pc[::3],               scalars=pt_src_id[::3].astype('int32'),              style='points',              #cmap='gwv',              point_size=2,              scalar_bar_args={'title': 'Point Source ID',                               'n_labels': 6,                               'position_x': 0.3}) p.subplot(0, 1) p.add_points(pc[::3],              scalars=classification[::3],              style='points',              cmap=['saddlebrown', 'forestgreen'],              render_points_as_spheres=True,              point_size=2,              scalar_bar_args={'title': 'Classification',                               'n_labels': 2,                               'position_x': 0.3}) p.link_views() p.camera_position = 'xz' p.camera.zoom(3) p.show_axes() p.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"02_static_snapshots_within_epoch.html#2-concept-of-several-static-snapshots-within-one-epoch","title":"2 Concept of several static snapshots within one epoch\u00b6","text":""},{"location":"02_static_snapshots_within_epoch.html#imports","title":"Imports\u00b6","text":""},{"location":"02_static_snapshots_within_epoch.html#example-21-tree-moving-in-the-wind-during-a-multi-station-tls-acquisition","title":"Example 2.1: Tree moving in the wind during a multi-station TLS acquisition\u00b6","text":"<p>In multi-station TLS acquisitions, movement of trees can result in duplication (\"re-occurrence\" / \"ghosting effects\") in the point cloud merged from multiple scans. This can be mimicked using the concept of many static snapshots. We start creating a 3D tree model which we animate in the wind using the Sapling Tree Gen add-on of Blender and its \"animation\" functionality. We then sample random frames and export the static mesh for this frame of the animation. This can be automatically done with the multi_epoch_b2h Blender add-on in this repository.</p>"},{"location":"02_static_snapshots_within_epoch.html#the-scene","title":"The scene\u00b6","text":"<p>We exported 6 static scenes which we will virtually scan from six different positions distributed around the scene. Let's look at one of the scenes.</p>"},{"location":"02_static_snapshots_within_epoch.html#the-survey","title":"The survey\u00b6","text":"<p>The corresponding survey looks like this. Note that we are using a custom platforms, which is a TLS tripod with a tilt mount. The scanner is therefore tilted by 90\u00b0 and scans left to right instead of top to bottom.</p>"},{"location":"02_static_snapshots_within_epoch.html#executing-the-simulation","title":"Executing the simulation\u00b6","text":""},{"location":"02_static_snapshots_within_epoch.html#visualizing-the-output","title":"Visualizing the output\u00b6","text":"<p>We are plotting the output coloured by the \"Point Source ID\", i.e., the ID of the scan position that the scan originates from (left), and coloured by classification (right; 0 = wood, 1 = leaf).</p>"},{"location":"03_animation_within_the_simulator.html","title":"3 Concept of animation within the simulator","text":"In\u00a0[1]: Copied! <pre>import os\nos.chdir(\"../demo\")\n</pre> import os os.chdir(\"../demo\") In\u00a0[2]: Copied! <pre>from pathlib import Path\nfrom IPython.display import Code\nfrom scripts.nb_utils import read_pc, read_from_output_folder, display_xml\nimport pyhelios\nfrom pyhelios.util.xmldisplayer import find_playback_dir\nimport numpy as np\nimport pyvista as pv\npv.set_jupyter_backend('trame')\n</pre> from pathlib import Path from IPython.display import Code from scripts.nb_utils import read_pc, read_from_output_folder, display_xml import pyhelios from pyhelios.util.xmldisplayer import find_playback_dir import numpy as np import pyvista as pv pv.set_jupyter_backend('trame') In\u00a0[3]: Copied! <pre>Code(display_xml('data/scenes/branch_anim_1.xml', line_limit=34), language='XML')\n</pre> Code(display_xml('data/scenes/branch_anim_1.xml', line_limit=34), language='XML') Out[3]: <pre>&lt;document&gt;\n    &lt;scene id=\"dyn_scene\" name=\"Dynamic scene\" dynTimeStep=\"0.020833333333333332\"&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data/sceneparts/box/box_unit_test.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            &lt;filter type=\"scale\"&gt;\n                &lt;param type=\"double\" key=\"scale\" value=\"0.15\" /&gt;\n            &lt;/filter&gt;\n        &lt;/part&gt;\n        &lt;!--Dynamic scenepart--&gt;\n        &lt;part&gt;\n            &lt;filter type=\"objloader\"&gt;\n                &lt;param type=\"string\" key=\"filepath\" value=\"data\\sceneparts\\animated_branch_1\\leaves.obj\" /&gt;\n                &lt;param type=\"string\" key=\"up\" value=\"z\" /&gt;\n            &lt;/filter&gt;\n            \n            \n            &lt;dmotion id=\"leaves_0\" loop=\"1\" next=\"leaves_1\"&gt;\n              &lt;motion type=\"rotation\" axis=\"0.000;1.000;0.000\" angle=\"0.00000000\" center=\"0.00000000;0.00000000;0.00000000\" autoCRS=\"1\" /&gt;\n              &lt;motion type=\"translation\" vec=\"0.00000000;0.00000000;0.00000000\" /&gt;\n            &lt;/dmotion&gt;\n            \n            &lt;dmotion id=\"leaves_1\" loop=\"1\" next=\"leaves_2\"&gt;\n              &lt;motion type=\"rotation\" axis=\"0.000;1.000;0.000\" angle=\"0.00000000\" center=\"0.00000000;0.00000000;0.00000000\" autoCRS=\"1\" /&gt;\n              &lt;motion type=\"translation\" vec=\"0.00000000;0.00000000;0.00000000\" /&gt;\n            &lt;/dmotion&gt;\n            \n            &lt;dmotion id=\"leaves_2\" loop=\"1\" next=\"leaves_3\"&gt;\n              &lt;motion type=\"rotation\" axis=\"0.000;1.000;0.000\" angle=\"0.00000000\" center=\"0.00000000;0.00000000;0.00000000\" autoCRS=\"1\" /&gt;\n              &lt;motion type=\"translation\" vec=\"0.00000000;0.00000000;0.00000000\" /&gt;\n            &lt;/dmotion&gt;\n            \n</pre> <p>Such a scene is of course difficult to write from scratch. We created this scene using the <code>dyn_b2h</code> Blender add-on for exporting Blender animations to HELIOS++ scenes. The add-on supports translations and rotations and before starting the export, the animation should be baked to keyframes. Find the corresponding .blend file here: TODO</p> <p>Let's have a quick look again what the static base scene looks like in 3D:</p> In\u00a0[4]: Copied! <pre>filepaths = Path('data/sceneparts/animated_branch_1').glob('*.obj')\np = pv.Plotter(notebook=True)\nfor f in filepaths:\n    mesh = pv.read(f)\n    p.add_mesh(mesh)\np.camera_position = 'yz'\np.show()\n</pre> filepaths = Path('data/sceneparts/animated_branch_1').glob('*.obj') p = pv.Plotter(notebook=True) for f in filepaths:     mesh = pv.read(f)     p.add_mesh(mesh) p.camera_position = 'yz' p.show() <p>It's leaning to the right, and during the simulation, it will rotate around its bottom until it is leaning to the left.</p> In\u00a0[5]: Copied! <pre>Code(display_xml('data/surveys/branch_anim_1.xml'), language='XML')\n</pre> Code(display_xml('data/surveys/branch_anim_1.xml'), language='XML') Out[5]: <pre>&lt;document&gt;\n        &lt;scannerSettings id=\"tls\" active=\"true\" pulseFreq_hz=\"2200000\" verticalResolution_deg=\"0.017\" horizontalResolution_deg=\"0.017\" /&gt;\n        &lt;survey name=\"branch_anim_1\" platform=\"data/platforms.xml#tripod\" scanner=\"data/scanners_tls_custom.xml#riegl_vz600i\" scene=\"data/scenes/branch_anim_1.xml#dyn_scene\"&gt;\n        &lt;leg&gt;\n            &lt;platformSettings x=\"-5\" y=\"0\" z=\"0\" /&gt;\n            &lt;scannerSettings template=\"tls\" headRotateStart_deg=\"260\" headRotateStop_deg=\"280\" trajectoryTimeInterval_s=\"0.05\" /&gt;\n        &lt;/leg&gt;\n        \n        &lt;/survey&gt;\n    &lt;/document&gt;\n</pre> In\u00a0[6]: Copied! <pre>!helios data/surveys/branch_anim_1.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/branch_anim_1.xml -q --lasOutput --zipOutput --rebuildScene In\u00a0[7]: Copied! <pre>output_path = Path(find_playback_dir('data/surveys/branch_anim_1.xml'))\npc_4d_1, object_id_1, _, _, gps_time_1, _ = read_from_output_folder(output_path)\nidx = object_id_1 != 0\npc_4d_1 = pc_4d_1[idx, :]\ngps_time_1 = gps_time_1[idx]\n</pre> output_path = Path(find_playback_dir('data/surveys/branch_anim_1.xml')) pc_4d_1, object_id_1, _, _, gps_time_1, _ = read_from_output_folder(output_path) idx = object_id_1 != 0 pc_4d_1 = pc_4d_1[idx, :] gps_time_1 = gps_time_1[idx] In\u00a0[8]: Copied! <pre>!helios data/surveys/branch_anim_2.xml -q --lasOutput --zipOutput --rebuildScene\n</pre> !helios data/surveys/branch_anim_2.xml -q --lasOutput --zipOutput --rebuildScene In\u00a0[9]: Copied! <pre>output_path = Path(find_playback_dir('data/surveys/branch_anim_2.xml'))\npc_4d_2, object_id_2, _, _, gps_time_2, _ = read_from_output_folder(output_path)\nidx = object_id_2 != 0\npc_4d_2 = pc_4d_2[idx, :]\ngps_time_2 = gps_time_2[idx]\n</pre> output_path = Path(find_playback_dir('data/surveys/branch_anim_2.xml')) pc_4d_2, object_id_2, _, _, gps_time_2, _ = read_from_output_folder(output_path) idx = object_id_2 != 0 pc_4d_2 = pc_4d_2[idx, :] gps_time_2 = gps_time_2[idx] In\u00a0[10]: Copied! <pre>p = pv.Plotter(notebook=True, shape=(1, 2)) \np.add_points(pc_4d_1, \n             scalars=gps_time_1,\n             style='points',\n             cmap='gwv',\n             point_size=2,\n             scalar_bar_args={'title': 'GPS Time [s] - scan 1',\n                              'fmt': '%10.1f',\n                              'n_labels': 4,\n                              'position_x': 0.3})\np.subplot(0, 1)\np.add_points(pc_4d_2, \n             scalars=gps_time_2,\n             style='points',\n             cmap='gwv',\n             point_size=2,\n             scalar_bar_args={'title': 'GPS Time [s] - scan 2',\n                              'fmt': '%10.2f',\n                              'n_labels': 4,\n                              'position_x': 0.3})\np.link_views()\np.camera_position = 'yz'\np.camera.zoom(1.4)\np.show()\n</pre> p = pv.Plotter(notebook=True, shape=(1, 2))  p.add_points(pc_4d_1,               scalars=gps_time_1,              style='points',              cmap='gwv',              point_size=2,              scalar_bar_args={'title': 'GPS Time [s] - scan 1',                               'fmt': '%10.1f',                               'n_labels': 4,                               'position_x': 0.3}) p.subplot(0, 1) p.add_points(pc_4d_2,               scalars=gps_time_2,              style='points',              cmap='gwv',              point_size=2,              scalar_bar_args={'title': 'GPS Time [s] - scan 2',                               'fmt': '%10.2f',                               'n_labels': 4,                               'position_x': 0.3}) p.link_views() p.camera_position = 'yz' p.camera.zoom(1.4) p.show()"},{"location":"03_animation_within_the_simulator.html#3-concept-of-animation-within-the-simulator","title":"3 Concept of animation within the simulator\u00b6","text":""},{"location":"03_animation_within_the_simulator.html#imports","title":"Imports\u00b6","text":""},{"location":"03_animation_within_the_simulator.html#example-31-tree-moving-in-the-wind-during-a-single-tls-scan","title":"Example 3.1: Tree moving in the wind during a single TLS scan\u00b6","text":"<p>In TLS acquisitions, vegetation can also appear as distorted if it is moving during the scan. These effects can be reproduced in the simulation. While vegetation actually deforms non-rigidly, we can assume that for many trees, a single branch moves rigidly. We will therefore use a HELIOS++ dynamic scene with rigid motions to recreate the distortion effects. We create two dynamic scenes. In both cases, the branch rotates about its base, but in different directions. With the scanner always rotating counter-clockwise, this will lead to a compressed branch (where scanner head and branch move in opposite directions) and an elongated branch (where scanner head and branch move in the same direction).</p>"},{"location":"03_animation_within_the_simulator.html#the-scene","title":"The scene\u00b6","text":"<p>Dynamic scenes in HELIOS++ are defined in the XML files using <code>motion</code>s (e.g., rotation and translation), which can be combined into one <code>dmotion</code> and changes together to motion sequences. We display just the first part of the scene XML below.</p>"},{"location":"03_animation_within_the_simulator.html#the-survey","title":"The survey\u00b6","text":"<p>The branch is simply scanned from a single position with a model of the RIEGL VZ-600i, which - as it supports a super high pulse frequency of 2,2 MHz - rotates pretty fast.</p>"},{"location":"03_animation_within_the_simulator.html#executing-the-simulation","title":"Executing the simulation\u00b6","text":""},{"location":"03_animation_within_the_simulator.html#visualizing-the-output","title":"Visualizing the output\u00b6","text":"<p>For the first scan, we expect that the resulting point cloud will appear compressed in the y-direction as the branch moves opposite than the scanner. For the second scan, we expect that the branch will appear elongated, as it moves in the same direction than the scanner. Let's have a look.</p>"}]}